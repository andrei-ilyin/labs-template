# Шаблон тестов к лабораторным работам

Данный репозиторий содержит заготовку, позволяющую создавать автоматизированные  
 тесты для лабораторных работ по программированию. 
 
При обучении промышленному программированию значительно более эффективным 
 методом проверки работ является юнит-тестирование, однако автоматизированные
 тестирующие системы по умолчанию работают не с таким форматом, а с форматом 
 олимпиад по программированию, где осуществляется только проверка на основе 
 ввода-вывода (но, например, не сигнатур и т. п.). 
Кроме того, по умолчанию в них отсутствует возможность компиляции и запуска 
 одновременно в нескольких редакциях (например, dbg, opt и asan).
Тем не менее, эти системы имеют возможности для встраивания собственной
 тестирующей прослойки, один из вариантов которой и содержится в данном
 репозитории.
 
Данная система уже нашла применение для организации онлайн-тестирования
 лабораторных работ по C++ через системы [iRunner 2](https://acm.bsu.by) и
 [Яндекс.Контест](https://contest.yandex.ru/).
Кроме того, с её помощью организовывалось автоматизированное 
 оффлайн-тестирвоание лабораторных работ по языку ассемблера.
 
Автором первых версий является Андрей Ильин (@andrei-ilyin),
позже большой вклад в доработку внёс Андрей Неверо (@anevero).

## Создание приватного форка репозитория

**TODO: Написать про то, как сделать приватную версию этого репозитория.**

После того, как закрытая версия репозитория готова, необходимо изменить:

- Токен для взаимодействия непосредственно тестов и тестирующей прослойки.
Необходимо сгенерировать случайный набор символов и прописать его в файлах 
`common/utils/utils.cc` и `common/testerlib/gtest_wrapper.py` вместо
значений по умолчанию - `ANTI_CHEAT_TOKEN_SECRET` и 
`ANTI_CHEAT_TOKEN_FILENAME`.

- Начальное значение для генератора рандомных чисел. Настраивается в нижней
части файла `common/utils/utils.h` как последний аргумент в `SAFE_TEST_A`.
В целом не должно быть критично, так что можно и оставлять значение по 
умолчнанию - 12345678.

- Если Вы планируете использовать Яндекс.Контест, то дополнительно в 
конструкторе класса `YandexContestInterface` в файле 
`common/testerlib/interface.py` измените имена входного и выходного файлов,
а также токены взаимодействия с чекером - `PUBLIC_SECRET_HERE` и 
`PRIVATE_SECRET_HERE`.

## Написание тестов

Файлы Google Test, Google Mock, Google Benchmark и файл *utils.h* со
вспомогательными макросами и функциями размещены в папке *common* и
используются во всех лабораторных. При написании тестов следует использовать
как макросы Google Test, так и обертки над ними из *utils.h*.

### Структура проекта с тестами

Каждой лабораторной работе соответствует отдельная подпапка в корне репозитория.
Если Вы используете какие-либо IDE (напр., CLion) для разработки тестов, то
просто откройте папку как проект.

В корне проекта располагается файл для системы сборки - `CmakeLists.txt`.
Файл написан таким образом, что его можно использовать для любой лабораторной, 
независимо от того, сколько файлов в ней и какие у них имена.
Обращаем внимание, что при использовании CLion необходимо вручную перезагрузить
CMake-проект в случае добавления/удаления каких-то файлов 
(`File > Reload CMake project`). 

Внутри проекта имеется несколько подпапок, а также вспомогательные файлы. 

- В подпапке `solution_src` размещаются все файлы решения (.cpp и .h), 
которые студенты должны отправлять на тестирование. По умолчанию тут должно 
располагаться авторское решение лабораторной, но сюда можно временно скопировать
и любое из решений студентов (например, если захотели отладить его на своих
тестах).

- В подпапке `tests_src` размещаются все файлы для тестирования (.cc и .h).
Тут могут быть .h файлы, которые участники подключают в своём решении, 
вспомогательные .cc-файлы с кодом и, самое главное, файлы с юнит-тестами, 
которые будут запускаться в тестирующей системе.

- Значение файлов `build.sh` и `tester_config.py` будет объяснено позже.

### Генераторы случайных чисел

Для генерации случайных чисел следует использовать функции `URandom64`,
`SRandom64`, `URandom32` и `SRandom32` из `utils.h`. Там же доступны
вспомогательные функции для генерации массивов и строк.

При использовании макроса `SAFE_TEST` (что, вообще говоря, почти обязательно)
выставлять генератору сиды вручную не требуется - это происходит
автоматически для каждого из тестов (вызов нужной функции встроен в макрос).

### Time limit

Для отлавливания неэффективных решений, не проходящих по времени, можно
использовать два макроса.

Первый - `ASSERT_NOT_INFINITE_LOOP` - ждет переданное количество миллисекунд
и фейлит тест, если переданная функция не завершила свою работу. В общем
случае использовать его явно не нужно, так как он встроен в макрос `SAFE_TEST`.

Второй - `ASSERT_DURATION_GE` - сравнивает время работы двух переданных
функций и фейлит тест, если время работы второй превышает время работы первой
более чем в 2 раза. Измерения проводятся достаточно точно (в микросекундах),
так что использовать этот макрос стоит лишь на функциях, которые отрабатывают
не мгновенно (иначе погрешность измерений будет слишком велика).

Есть развернутая версия второго макроса - `ASSERT_DURATION_GE_A`. В нее
третьим аргументом можно передать константу, определяющую максимальное
допустимое отношение времени работы второй функции ко времени работы первой
(в макросе `ASSERT_DURATION_GE` она, как уже упоминалось, равна двум).

### Исключения с сообщением заданного формата

В Google Test встроен макрос `ASSERT_THROW`, который позволяет проверить,
выбрасывает ли функция исключение нужного типа. К сожалению, он не позволяет
проверить формат сообщения `what()`. Если необходимость в этом возникла,
можно использовать макрос `CATCH_EXCEPTION`, в который передается функция,
тип исключения, которое должно быть выброшено, а также сообщение, которое
должно быть привязано к исключению.

### SAFE_TEST

При создании тестов следует использовать не стандартный макрос `TEST()` из
Google Test, а обертку над ним из *utils.h* - `SAFE_TEST()`. `SAFE_TEST`
разворачивается в `SAFE_TEST_A`, который в свою очередь уже содержит
стандартный `TEST`.

`SAFE_TEST` отличается от `TEST` тем, что проводит дополнительные операции.
Как можно увидеть в исходном коде, он:
* Устанавливает заданный сид генератору случайных чисел (чтобы случайные
числа были предсказуемыми и не отличались при различных запусках).
* Используя макрос `ASSERT_NOT_INFINITE_LOOP`, проверяет, что тело теста
не зацикливается навечно. TL по умолчанию - 30 секунд.
* Запускает тест переданное количество раз подряд (по умолчанию - три),
устанавливая каждый раз исходный сид генератору случайных чисел. Это нужно
для того, чтобы отлавливать, например, неопределенное поведение.

Как нетрудно подсчитать, функция тестирования реально запускается `N + 1`
раз, где `N` - количество итераций цикла (по умолчанию `N = 3`). Это следует
учитывать при написании больших тестов (они могут работать в четыре раза
дольше, чем предполагается). В крайнем случае можно вручную задать количество
итераций, используя макрос `SAFE_TEST_A`.

### Другие функции

Можно изучить самостоятельно.

## Интеграция с тестирующей системой

### Подготовка лабораторной к тестированию в системе 

Для того, чтобы студенты могли сдавать лабораторную в систему автоматического
тестирования, необходимо загрузить в неё два файла:

- Скрипт компиляции `build.sh`, который располагается в корне папки с
лабораторной работой. В общем случае в лабах изменяется только список файлов
из решения, которые нужно компилировать, но возможны и более экзотические
сценарии сборки. Кроме того, в нём можно управлять тем, какая часть лога
компиляции будет видна в системе.

- Архив с материалами для тестирования (`package.zip`). Содержит в себе общие
библиотеки и файлы, специфичные для лабораторной работы (исходники тестов и
`tester_config.py`). Генерируется скриптами `make_package.sh LAB_FOLDER_NAME`.

Файл `tester_config.py`, расположенный в корне папки с лабораторной работой,
содержит описание запускаемых тестов и баллов за них. Тут настраивается, в том
числе, степень детализации отчёта (показывать имена тестов или только группы) и
зависимости между тестами.

Проверить правильность работы файлов `build.sh` и `tester_config.py` можно
запустив нужный из скриптов `validate.sh [--no-zip] LAB_FOLDER_NAME`. 
Если указан ключ `--no-zip`, то решением участника считается не всё содержимое
подпапки `solution_src`, а только файл `solution_src\solution.cpp`. Такой
режим применяется в первых лабораторных, когда студенты отправляют на проверку 
не zip-архив, а одиночный cpp-файл.

Отметим, что если для данной лабораторной разрешён вариант "Отправить CPP-файл",
то необходимо предварительно внести изменения в `build.sh` (см. строки 34-37).

### Настройка задачи в iRunner 2

Для быстрой генерации архива с тестами используйте команду
`irunner_make_package.sh LAB_FOLDER_NAME`.

Если же Вы хотите проверить правильность работы файлов `build.sh` и 
`tester_config.py`, то вместо этого запустите скрипт
`irunner_validate.sh [--no-zip] LAB_FOLDER_NAME`. 

После того, как пакет для задачи готов и проверен, создайте в iRunner новую
задачу: откройте в меню "Задачи", выберите слева нужную папку, нажмите
кнопку "Новая задача", укажите номер задачи и её название, после чего нажмите
"Сохранить".

Далее на вкладке "Свойства", которая открылась, в самом низу укажите, какого 
рода файлы можно отправлять в данной лабораторной: 
- если решение многофайловое, то единственным возможным способом является 
отправка в виде архива, поэтому укажите в поле `zip`.
- если в данной задаче решением является всего один файл с исходным кодом, то 
можно также разрешить отправку непосредственно .cpp-файла указав в поле 
`cpp, zip`. 

После этого необходимо загрузить в систему скрипт компиляции и пакет с тестами.
Для этого переходим на вкладку "Файлы" и добавляем в секцию "Файлы с кодом":
- Файл `build.sh`, указав в качестве типа файла `Библиотека`, а в качестве
компилятора - `UNIX Shell`.
- Файл `build.sh`, указав в качестве типа файла `Программа проверки`, а в
качестве компилятора - `ZIP Archive`. 

После этого можете проверить корректность настройки используя вкладки 
"Отправить решение" и "Решения".

### Настройка задачи в Яндекс.Контест

**TODO: Написать про то, как настраивать систему.**

### Шаблон решения

Часть лабораторных может иметь открытые материалы - файлы, которые 
предоставляются студенту вместе с условием (вспомогательные классы, сигнатуры
функций и т. п.). Все такие материалы для единообразия следует размещать в
подпапке `template` соответствующей лабораторной.

### Функция main()

Важно отметить, что и шаблон, и отправляемое в систему решение может содержать 
функцию `int main()`, в которой будет содержаться произвольный код, 
предназначенный для локального запуска на компьютерах студентов.
Таким образом, например, до изучения студентами темы "юнит-тестирование",
можно помещать в этот блок шаблона тесты на основе assert. 

Для того, чтобы на сервере эта функция из решения не конфликтовала со встроенной
функцией для запуска юнит-тестов, следует обернуть её по аналогии с механизмом
include guard:
```
#ifndef IGNORE_SOLUTION_MAIN
int main() {
  // ...Тут пишем произвольный код...
  return 0;
}
#endif  // IGNORE_SOLUTION_MAIN
```

### Санитайзеры 

На данный момент все тесты запускаются в трёх конфигурациях:
1) Без каких-либо оптимизаций (-O0)
2) С включенными оптимизациями (-O2)
3) С включенными AddressSanitizer и UndefinedSanitizer.

Из-за особенностей библиотеки Google Test, использование данного санитайзера
будет приводить к ложным срабатываниям, в результате которого никакие решения не 
смогут пройти тесты. Для решения этой проблемы необходима перекомпиляция с 
включенным санитайзером `libc++` и `libc++-abi` 
[(источник)](https://github.com/google/sanitizers/wiki/MemorySanitizerLibcxxHowTo). 
На данный момент MemorySanitizer в лабораторных не запускается.

## Статус C++20

В некоторых лабораторных, возможно, получится использовать некоторые
возможности C++20 (в частности, spaceship operator, <=>).

В случае необходимости проверки C++20-кода рекомендуется использовать
компилятор gcc-10 или выше, clang-10 или выше. В Ubuntu 20.04 они ставятся
из стандартных репозиториев, в Ubuntu 18.04 clang-10 ставится из
стандартных репозиториев, gcc-10 - из
[тестового](https://launchpad.net/~ubuntu-toolchain-r/+archive/ubuntu/test).

В CLion 2020.1 и более ранних версиях присутствует баг с определением
пространств имен в libstdc++, из-за которого анализ кода при выставлении
20-го стандарта в CMake не работает (все начинает гореть красным). Для
решения этой проблемы соответствующие лабораторные линкуются с libc++, если
установлен 20-ый стандарт. По умолчанию libc++ не входит в пакеты clang / llvm,
ее необходимо установить дополнительно:

`sudo apt install libc++abi-10-dev libc++-10-dev`

Доступна в тех же репозиториях, откуда загружался clang.
