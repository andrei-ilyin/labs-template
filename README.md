# Шаблон тестов к лабораторным работам

Данный репозиторий содержит заготовку, позволяющую создавать автоматизированные  
тесты для лабораторных работ по программированию. 
 
При обучении промышленному программированию значительно более эффективным 
методом проверки работ является юнит-тестирование, однако автоматизированные
тестирующие системы по умолчанию работают не с таким форматом, а с форматом 
олимпиад по программированию, где осуществляется только проверка на основе 
ввода-вывода (но, например, не сигнатур и т. п.). 
Кроме того, по умолчанию в них отсутствует возможность компиляции и запуска 
одновременно в нескольких редакциях (например, dbg, opt и asan).
Тем не менее, эти системы имеют возможности для встраивания собственной
тестирующей прослойки, один из вариантов которой и содержится в данном
репозитории.
 
Данная система уже нашла применение для организации онлайн-тестирования
лабораторных работ по C++ через системы [iRunner 2](https://acm.bsu.by) и
[Яндекс.Контест](https://contest.yandex.ru/).
Кроме того, с её помощью организовывалось автоматизированное 
оффлайн-тестирование лабораторных работ по языку ассемблера.
 
Автором первых версий является Андрей Ильин (@andrei-ilyin),
позже большой вклад в доработку внёс Андрей Неверо (@anevero).

## Создание приватного форка репозитория

GitHub не позволяет явно создать приватный форк. Вместо этого можно скопировать
основной репозиторий в свой личный, а затем время от времени вручную сливать в
него изменения.

Далее везде используются SSH-адреса репозиториев, при необходимости вы можете
заменить их на HTTPS.

Для дублирования репозитория создайте личный приватный репозиторий и 
воспользуйтесь следующими командами:
```
git clone --bare git@github.com:andrei-ilyin/labs-template.git
cd labs-template.git
git push --mirror git@github.com:me/my_private_repo.git
cd ..
rm -rf labs-template.git
```

После выполнения данных шагов вы можете склонировать свой личный репозиторий
в любую директорию для последующей работы.

Чтобы обеспечить возможность слияния изменений из основного репозиторий в свой,
можно явно подключить основной c нестандартным псевдонимом (например, `base`).
Для этого в папке вашего личного репозитория выполните команду:
```
git remote add base git@github.com:andrei-ilyin/labs-template.git
```

После этого, чтобы слить изменения из основного репозитория в личный, можно
использовать команды:
```
git pull base master
git push origin master
```

После того, как закрытая версия репозитория готова, необходимо изменить:

- Токен для взаимодействия непосредственно тестов и тестирующей прослойки.
Необходимо сгенерировать случайный набор символов и прописать его в файлах 
`common/utils/utils.cc` и `common/testerlib/gtest_wrapper.py` вместо
значений по умолчанию - `ANTI_CHEAT_TOKEN_SECRET` и 
`ANTI_CHEAT_TOKEN_FILENAME`.

- Начальное значение для генератора рандомных чисел. Настраивается в нижней
части файла `common/utils/utils.h` как последний аргумент в `SAFE_TEST_A`.
В целом не должно быть критично, так что можно и оставлять значение по 
умолчнанию - 12345678.

- Если Вы планируете использовать Яндекс.Контест, то дополнительно в 
конструкторе класса `YandexContestInterface` (см.  
`common/testerlib/interface.py`), измените токены взаимодействия с чекером -
`PUBLIC_SECRET_HERE` и `PRIVATE_SECRET_HERE`. Токены должны соответствовать 
содержимому файлов `01.a` и `02.a` в тестирующей системе.

- Если генерация архива для Яндекс.Контеста не нужна (Вы используете только
iRunner), то можете закомментировать последние строчки в файле
`make_package.sh`.

## Написание тестов

Файлы Google Test, Google Mock, Google Benchmark и файл *utils.h* со
вспомогательными макросами и функциями размещены в папке *common* и
используются во всех лабораторных. При написании тестов следует использовать
как макросы Google Test, так и обертки над ними из *utils.h*.

### Структура проекта с тестами

Каждой лабораторной работе соответствует отдельная подпапка в корне репозитория.
Если Вы используете какие-либо IDE (например, CLion) для разработки тестов, то
просто откройте папку как проект.

В корне проекта располагается файл для системы сборки - `CMakeLists.txt`.
Файл написан таким образом, что его можно использовать для любой лабораторной, 
независимо от того, сколько файлов в ней и какие у них имена.
Обращаем внимание, что при использовании CLion необходимо вручную перезагрузить
CMake-проект в случае добавления/удаления каких-то файлов 
(`File > Reload CMake project`). 

Внутри проекта имеется несколько подпапок, а также вспомогательные файлы. 

- В подпапке `solution_src` размещаются все файлы решения (.cpp и .h), 
которые студенты должны отправлять на тестирование. По умолчанию тут должно 
располагаться авторское решение лабораторной, но сюда можно временно скопировать
и любое из решений студентов (например, если захотели отладить его на своих
тестах).

- В подпапке `tests_src` размещаются все файлы для тестирования (.cc и .h).
Тут могут быть .h файлы, которые участники подключают в своём решении, 
вспомогательные .cc-файлы с кодом и, самое главное, файлы с юнит-тестами, 
которые будут запускаться в тестирующей системе.

- Значение файлов `build.sh` и `tester_config.py` будет объяснено позже.

### Компиляция проекта

Настоятельно рекомендуется использовать для сборки проекта компилятор `clang`
в Linux-окружении, причем желательно совместно со средой разработки CLion.

При использовании `clang` включаются санитайзеры и генерация отчетов code
coverage, которые удобно просматривать в CLion
([документация](https://www.jetbrains.com/help/clion/code-coverage-clion.html)).
Для корректной обработки и отображения отчетов code coverage необходимо в
настройках CLion (`Build, execution, deployment - Coverage`) указать пути к
утилитам `gcov`, `llvm-cov`, `llvm-profdata`. Данные утилиты входят в состав
пакетов `gcc` и `llvm`, так что с их установкой проблем возникнуть не должно.
Пути обычно выглядят как `/usr/bin/gcov-9`, `/usr/bin/llvm-cov-11` и так далее
(в `/usr/bin/` есть все необходимые символические ссылки).

Обратите внимание, что при использовании WSL под Windows пути нужно указывать
ровно в таком же формате (не нужно пытаться как-то учитывать файловую систему
Windows).

### Генераторы случайных чисел

Для генерации случайных чисел следует использовать функции `URandom64`,
`SRandom64`, `URandom32` и `SRandom32` из `utils.h`. Там же доступны
вспомогательные функции для генерации массивов и строк.

При использовании макроса `SAFE_TEST` (что, вообще говоря, почти обязательно)
выставлять генератору сиды вручную не требуется - это происходит
автоматически для каждого из тестов (вызов нужной функции встроен в макрос).

### Time limit

Для отлавливания неэффективных решений, не проходящих по времени, можно
использовать два макроса.

Первый - `ASSERT_NOT_INFINITE_LOOP` - ждет переданное количество миллисекунд
и фейлит тест, если переданная функция не завершила свою работу. В общем
случае использовать его явно не нужно, так как он встроен в макрос `SAFE_TEST`.

Второй - `ASSERT_DURATION_GE` - сравнивает время работы двух переданных
функций и фейлит тест, если время работы второй превышает время работы первой
более чем в 2 раза. Измерения проводятся достаточно точно (в микросекундах),
так что использовать этот макрос стоит лишь на функциях, которые отрабатывают
не мгновенно (иначе погрешность измерений будет слишком велика).

Есть развернутая версия второго макроса - `ASSERT_DURATION_GE_A`. В нее
третьим аргументом можно передать константу, определяющую максимальное
допустимое отношение времени работы второй функции ко времени работы первой
(в макросе `ASSERT_DURATION_GE` она, как уже упоминалось, равна двум).

### Исключения с сообщением заданного формата

В Google Test встроен макрос `ASSERT_THROW`, который позволяет проверить,
выбрасывает ли функция исключение нужного типа. К сожалению, он не позволяет
проверить формат сообщения `what()`. Если необходимость в этом возникла,
можно использовать макрос `CATCH_EXCEPTION`, в который передается функция,
тип исключения, которое должно быть выброшено, а также сообщение, которое
должно быть привязано к исключению.

### SAFE_TEST

При создании тестов следует использовать не стандартный макрос `TEST()` из
Google Test, а обертку над ним из *utils.h* - `SAFE_TEST()`. `SAFE_TEST`
разворачивается в `SAFE_TEST_A`, который в свою очередь уже содержит
стандартный `TEST`.

`SAFE_TEST` отличается от `TEST` тем, что проводит дополнительные операции.
Как можно увидеть в исходном коде, он:
* Устанавливает заданный сид генератору случайных чисел (чтобы случайные
числа были предсказуемыми и не отличались при различных запусках).
* Используя макрос `ASSERT_NOT_INFINITE_LOOP`, проверяет, что тело теста
не зацикливается навечно. TL по умолчанию - 30 секунд.
* Запускает тест переданное количество раз подряд (по умолчанию - два),
устанавливая каждый раз исходный сид генератору случайных чисел. Это нужно
для того, чтобы отлавливать, например, неопределенное поведение.

Как нетрудно подсчитать, функция тестирования реально запускается `N + 1`
раз, где `N` - количество итераций цикла (по умолчанию `N = 2`). Это следует
учитывать при написании больших тестов (они могут работать в три раза
дольше, чем предполагается). В крайнем случае можно вручную задать количество
итераций, используя макрос `SAFE_TEST_A`.

### Другие функции

Можно изучить самостоятельно.

## Интеграция с тестирующей системой

### Подготовка лабораторной к тестированию в системе 

Для того, чтобы студенты могли сдавать лабораторную в систему автоматического
тестирования, необходимо загрузить в неё два файла:

- Скрипт компиляции `build.sh`, который располагается в корне папки с
лабораторной работой. В общем случае в лабах изменяется только список файлов
из решения, которые нужно компилировать, но возможны и более экзотические
сценарии сборки. Кроме того, в нём можно управлять тем, какая часть лога
компиляции будет видна в системе.

- Архив с материалами для тестирования (`package.zip`). Содержит в себе общие
библиотеки и файлы, специфичные для лабораторной работы (исходники тестов и
`tester_config.py`). Генерируется скриптом `./make_package.sh LAB_FOLDER_NAME`.

Файл `tester_config.py`, расположенный в корне папки с лабораторной работой,
содержит описание запускаемых тестов и баллов за них. Тут настраивается, в том
числе, степень детализации отчёта (показывать имена тестов или только группы) и
зависимости между тестами.

Проверить правильность работы файлов `build.sh` и `tester_config.py` можно
запустив скрипт `./validate.sh [--no-zip] LAB_FOLDER_NAME`. 
Если указан ключ `--no-zip`, то решением участника считается не всё содержимое
подпапки `solution_src`, а только файл `solution_src\solution.cpp`. Такой
режим применяется в первых лабораторных, когда студенты отправляют на проверку 
не zip-архив, а одиночный cpp-файл. Запуск скрипта `validate.sh` автоматически
перегенерирует архив с материалами, т. е. внутри себя этот скрипт запускает, в
том числе, `make_package.sh`.

Отметим, что если для данной лабораторной разрешён вариант "Отправить CPP-файл",
то необходимо предварительно внести изменения в `build.sh` (см. строки 34-37).

### Настройка задачи в iRunner 2

После того, как пакет для задачи готов и проверен, создайте в iRunner новую
задачу: откройте в меню "Задачи", выберите слева нужную папку, нажмите
кнопку "Новая задача", укажите номер задачи и её название, после чего нажмите
"Сохранить".

Далее на вкладке "Свойства", которая открылась, в самом низу укажите, какого 
рода файлы можно отправлять в данной лабораторной: 
- если решение многофайловое, то единственным возможным способом является 
отправка в виде архива, поэтому укажите в поле `zip`.
- если в данной задаче решением является всего один файл с исходным кодом, то 
можно также разрешить отправку непосредственно .cpp-файла указав в поле 
`cpp, zip`. 

После этого необходимо загрузить в систему скрипт компиляции и пакет с тестами.
Для этого переходим на вкладку "Файлы" и добавляем в секцию "Файлы с кодом":
- Файл `build.sh`, указав в качестве типа файла `Библиотека`, а в качестве
компилятора - `UNIX Shell`.
- Файл `build.sh`, указав в качестве типа файла `Программа проверки`, а в
качестве компилятора - `ZIP Archive`. 

После этого можете проверить корректность настройки используя вкладки 
"Отправить решение" и "Решения".

### Настройка задачи в Яндекс.Контест

**Важное замечание:** Из-за различий в версии компилятора (в ЯКонтесте 
установлен Clang 3.8), скорее всего будет необходимо отключить механизм 
прекомпиляции библиотеки Google Test, иначе получите ошибку линковки на сервере.
Для этого при подготовке/валидации первым аргументом укажите скрипту 
`--no-precompile`.

Перейдите на вкладку `Загруженные файлы`, нажмите `Выбрать файл` и загрузите на
сервер файл `package-yacontest.zip` соответствующей лабы. Таким же образом
можно будет в дальнейшем обновить тесты или скрипт компиляции.

Загрузите в папку `checkers` файл `common/yacontest/checker.cpp`.

Следующим шагом перейдите на вкладку `Настройки` и установите:
- Короткое и полное название задачи.
- Тип задачи: `PROBLEM_WITH_CHECKER`.
- Названия входного/выходного файлов (по умолчанию `INPUT_FILE_NAME` и
  `OUTPUT_FILE_NAME`).
- Запретите чтение/запись в stdin/stdout.
- Разрешите создание дополнительных файлов.
- Обновите ограничения на время и память во время запуска и компиляции.
- Нажмите кнопку `Скомилировать чекер` и выберите файл `checkers/checker.cpp`
- Установите тип чекера `EJUDGE_EXITCODE_CHECKER`.
- Выберите `ДА` в пункте про выставление баллов чекером.
- В пункте `Файлы чекера` выберите `checkers/checker`.
- В пункте `Файлы для компиляции` добавьте 4 файла: `Makefile`, `run_build.sh`,
  `build.sh` и `package_zip`.
- Нажмите `Сохранить` в правом нижнем углу экрана.

Теперь перейдите во вкладку `Тесты и решения` и с помощью кнопки `Создать тест`
добавьте два теста:

- Тест с именами файлов `01`/`01.a`. 
В качестве входного файла укажите `public`, а в качестве файла с ответом -
токен публичного теста (`PUBLIC_SECRET_HERE`).

- Тест с именами файлов `02`/`02.a`. 
В качестве входного файла укажите `private`, а в качестве файла с ответом -
токен оцениваемого теста (`PRIVATE_SECRET_HERE`).

После этого отредактируйте секцию `Наборы тестов`:
- Набор `samples` должен состоять только из первого теста
- Набор `All tests` должен состоять только из второго теста

*Замечание: Часть из операций можно не выполнять для каждой из лаб, если 
воспользоваться возможностью клонирования задач.*

В настройках **соревнования** укажите:

- В качестве компилятора единственным доступным оставьте Make.

- Показывать для всех тестов: вердикт, время/память, stderr.
- Очки показывать для тестов с начисленными баллами.
- Все остальные части отчёта (ввод, вывод, ответ, сообщение чекер) НЕ показывать!

- Ставим тип монитора `SCORING`, его видимость - судьям.

### Шаблон решения

Часть лабораторных может иметь открытые материалы - файлы, которые 
предоставляются студенту вместе с условием (вспомогательные классы, сигнатуры
функций и т. п.). Все такие материалы для единообразия следует размещать в
подпапке `template` соответствующей лабораторной.

### Функция main()

Важно отметить, что и шаблон, и отправляемое в систему решение может содержать 
функцию `int main()`, в которой будет содержаться произвольный код, 
предназначенный для локального запуска на компьютерах студентов.
Таким образом, например, до изучения студентами темы "юнит-тестирование",
можно помещать в этот блок шаблона тесты на основе assert. 

Для того, чтобы на сервере эта функция из решения не конфликтовала со встроенной
функцией для запуска юнит-тестов, следует обернуть её по аналогии с механизмом
include guard:
```
#ifndef IGNORE_SOLUTION_MAIN
int main() {
  // ...Тут пишем произвольный код...
  return 0;
}
#endif  // IGNORE_SOLUTION_MAIN
```

### Санитайзеры 

На данный момент все тесты запускаются в трёх конфигурациях:
1) Без каких-либо оптимизаций (-O0)
2) С включенными оптимизациями (-O2)
3) С включенными AddressSanitizer и UndefinedSanitizer.

Из-за особенностей библиотеки Google Test, использование MemorySanitizer
будет приводить к ложным срабатываниям, в результате которых никакие решения не 
смогут пройти тесты. Для решения этой проблемы необходима перекомпиляция с 
включенным санитайзером `libc++` и `libc++-abi` 
[(источник)](https://github.com/google/sanitizers/wiki/MemorySanitizerLibcxxHowTo). 
На данный момент MemorySanitizer в лабораторных не запускается.

## Стандарт
 
### Поддержка в тестирующих системах

На серверах iRunner 2 для компиляции используется Clang 10, в котором полностью
поддерживается C++17 и частично реализован C++20.

На серверах Яндекс.Контеста установлен Clang 3.8, так что даже для стандарта 
C++17 имеется лишь частичная поддержка. 

Если С++17 в Яндекс.Контесте очень нужен, то используйте GNU C++ Compiler.
В своё время мы сделали выбор в пользу более старого Clang потому, что там 
санитайзеры работают лучше, отлавливают больше багов (как показал опыт).

Обращаем внимание, что для компиляции с Clang в ЯКонтесте следует изменить 
build-скрипт, дабы использовать флаг `-std=c++1z` вместо привычного. 

### C++20
 
Если лабораторные работы (решения, тесты) предполагают использование
возможностей C++20 (spaceship operator, concepts и так далее), следует
использовать как минимум Clang 10. Для работы с нововведениями
стандартной библиотеки может потребоваться ее актуальная реализация
(по умолчанию `clang` будет использовать `libstdc++`, которую найдет в системе,
а она может не содержать нужной функциональности).

Для установки актуальной версии `libc++` воспользуйтесь вашим пакетным
менеджером. Например:
```
sudo apt install libc++abi-10-dev libc++-10-dev
```
После этого в CMake-скрипте необходимо добавить в `CXX_FLAGS` флаг
`-stdlib=libc++`.
